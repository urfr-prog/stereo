<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ADAM - Kaizen 1 v9</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body {
            background-color: #12131a;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(4, var(--cell));
            grid-template-rows: repeat(4, var(--cell));
            gap: var(--gap);
            --cell: min(80px, 20vw);
            --gap: 8px;
        }
        
        .cell {
            width: var(--cell);
            height: var(--cell);
            position: relative;
        }
        
        .square {
            width: 100%;
            height: 100%;
            background-color: transparent;
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
            cursor: pointer;
            border-radius: 12px;
        }
        
        .square.empty {
            cursor: default;
            border: 2px dashed rgba(180, 180, 190, 0.15);
            border-radius: 12px;
        }
        
        .square svg {
            width: 100%;
            height: 100%;
        }
        
        svg .separator {
            stroke: rgba(180, 180, 190, 0.3);
            stroke-width: 1;
        }
        
        svg line.icon,
        svg path.icon,
        svg circle.icon,
        svg rect.icon {
            stroke: rgba(180, 180, 190, 0.35);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }
        
        svg circle.point {
            fill: rgba(180, 180, 190, 0.35);
        }
        
        /* Ancien système de bordures supprimé - remplacé par pseudo-éléments ci-dessus */
        
        /* === ÉTATS PAR FACE INDIVIDUELLE === */
        
        /* Face1 states */
        .face1-white line.icon, .face1-white path.icon, 
        .face1-white circle.icon, .face1-white rect.icon {
            stroke: rgba(180, 180, 190, 0.35);
        }
        .face1-white circle.point {
            fill: rgba(180, 180, 190, 0.35);
        }
        
        .face1-silver line.icon, .face1-silver path.icon, 
        .face1-silver circle.icon, .face1-silver rect.icon {
            stroke: #22d3ee;
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4));
        }
        .face1-silver circle.point {
            fill: #22d3ee;
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4));
        }
        
        .face1-gold line.icon, .face1-gold path.icon, 
        .face1-gold circle.icon, .face1-gold rect.icon {
            stroke: #ffd700;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
        }
        .face1-gold circle.point {
            fill: #ffd700;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
        }
        
        .face1-emerald line.icon, .face1-emerald path.icon, 
        .face1-emerald circle.icon, .face1-emerald rect.icon {
            stroke: #34d399;
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9));
        }
        .face1-emerald circle.point {
            fill: #34d399;
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9));
        }
        
        .face1-cosmic line.icon, .face1-cosmic path.icon, 
        .face1-cosmic circle.icon, .face1-cosmic rect.icon {
            stroke: #c4b5fd;
            filter: drop-shadow(0 0 8px rgba(131, 56, 236, 0.9));
        }
        .face1-cosmic circle.point {
            fill: #c4b5fd;
            filter: drop-shadow(0 0 8px rgba(131, 56, 236, 0.9));
        }
        
        /* Face2 states */
        .face2-white line.icon, .face2-white path.icon, 
        .face2-white circle.icon, .face2-white rect.icon {
            stroke: rgba(180, 180, 190, 0.35);
        }
        .face2-white circle.point {
            fill: rgba(180, 180, 190, 0.35);
        }
        
        .face2-silver line.icon, .face2-silver path.icon, 
        .face2-silver circle.icon, .face2-silver rect.icon {
            stroke: #22d3ee;
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4));
        }
        .face2-silver circle.point {
            fill: #22d3ee;
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4));
        }
        
        .face2-gold line.icon, .face2-gold path.icon, 
        .face2-gold circle.icon, .face2-gold rect.icon {
            stroke: #ffd700;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
        }
        .face2-gold circle.point {
            fill: #ffd700;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
        }
        
        .face2-emerald line.icon, .face2-emerald path.icon, 
        .face2-emerald circle.icon, .face2-emerald rect.icon {
            stroke: #34d399;
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9));
        }
        .face2-emerald circle.point {
            fill: #34d399;
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9));
        }
        
        .face2-cosmic line.icon, .face2-cosmic path.icon, 
        .face2-cosmic circle.icon, .face2-cosmic rect.icon {
            stroke: #c4b5fd;
            filter: drop-shadow(0 0 8px rgba(131, 56, 236, 0.9));
        }
        .face2-cosmic circle.point {
            fill: #c4b5fd;
            filter: drop-shadow(0 0 8px rgba(131, 56, 236, 0.9));
        }
    </style>
</head>
<body>
    <div class="grid" id="grid"></div>

    <script>
        const COLS = 4;
        const ROWS = 4;
        const TOTAL = 16;
        const ROTATION_SPEED = 400;
        const STATE_ORDER = ['white', 'silver', 'gold', 'emerald', 'cosmic'];
        
        let grid = document.getElementById('grid');
        let isAnimating = false;
        let isLocalRotating = false;
        let dragState = null;
        let dominos = [];
        
        // Icônes niveau 1
        const ICONS = {
            chevron: { f1: 'M20 32L45 12L70 32', f2: 'M20 12L45 32L70 12', t: 'path' },
            circle: { f1: '45,22,12', f2: '45,22,12', t: 'circle' },
            twoCircles: { f1: '30,22,8|60,22,8', f2: '30,22,8|60,22,8', t: 'circles' },
            line: { f1: '15,22,75,22', f2: '15,22,75,22', t: 'line' },
            threeLines: { f1: '25,10,25,34|45,10,45,34|65,10,65,34', f2: '25,10,25,34|45,10,45,34|65,10,65,34', t: 'lines' },
            twoPoints: { f1: '30,22,4|60,22,4', f2: '30,22,4|60,22,4', t: 'points' },
            square: { f1: '25,10,40,24,3', f2: '25,10,40,24,3', t: 'rect' },
            wave: { f1: 'M10 22Q28 6 45 22Q62 38 80 22', f2: 'M10 22Q28 6 45 22Q62 38 80 22', t: 'path' }
        };
        
        const iconKeys = Object.keys(ICONS);
        
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 1103515245 + 12345) & 0x7fffffff;
                return state / 0x7fffffff;
            };
        }
        
        function initDominos() {
            const rng = seededRandom(12345);
            dominos = [];
            
            for (let i = 0; i < TOTAL; i++) {
                const x = i % COLS;
                const y = Math.floor(i / COLS);
                dominos.push({
                    face1: iconKeys[Math.floor(rng() * iconKeys.length)],
                    face2: iconKeys[Math.floor(rng() * iconKeys.length)],
                    face1State: 'white',  // État individuel face1
                    face2State: 'white',  // État individuel face2
                    rotation: ((x + y) % 2 === 0) ? 0 : 90,
                    state: 'white'
                });
            }
        }
        
        function renderIcon(icon, isFace2, faceState) {
            // Face vide
            if (icon === 'empty') return '';
            
            const d = ICONS[icon];
            if (!d) return '';
            const data = isFace2 ? d.f2 : d.f1;
            const faceClass = isFace2 ? 'face2' : 'face1';
            const stateClass = `${faceClass}-${faceState}`;
            
            if (d.t === 'path') return `<path class="icon ${stateClass}" d="${data}"/>`;
            if (d.t === 'circle') {
                const [cx, cy, r] = data.split(',');
                return `<circle class="icon ${stateClass}" cx="${cx}" cy="${cy}" r="${r}"/>`;
            }
            if (d.t === 'line') {
                const [x1, y1, x2, y2] = data.split(',');
                return `<line class="icon ${stateClass}" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`;
            }
            if (d.t === 'rect') {
                const [x, y, w, h, rx] = data.split(',');
                return `<rect class="icon ${stateClass}" x="${x}" y="${y}" width="${w}" height="${h}" rx="${rx}"/>`;
            }
            if (d.t === 'lines') {
                return data.split('|').map(p => {
                    const [x1, y1, x2, y2] = p.split(',');
                    return `<line class="icon ${stateClass}" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`;
                }).join('');
            }
            return data.split('|').map(p => {
                const v = p.split(',');
                return (d.t === 'circles' || d.t === 'points')
                    ? `<circle class="${d.t === 'points' ? 'point' : 'icon'} ${stateClass}" cx="${v[0]}" cy="${v[1]}" r="${v[2]}"/>`
                    : `<line class="icon ${stateClass}" x1="${v[0]}" y1="${v[1]}" x2="${v[2]}" y2="${v[3]}"/>`;
            }).join('');
        }
        
        function renderDomino(d) {
            // Déterminer les couleurs de bordure selon les états
            const borderColors = {
                white: 'rgba(180, 180, 190, 0.35)',
                silver: 'rgba(6, 182, 212, 0.6)',
                gold: 'rgba(255, 215, 0, 0.7)',
                emerald: 'rgba(52, 211, 153, 0.9)',
                cosmic: 'url(#cosmicGradient)'
            };
            
            const face1Color = borderColors[d.face1State];
            const face2Color = borderColors[d.face2State];
            
            // Médiane = couleur de l'état le plus fort
            const STATE_ORDER = ['white', 'silver', 'gold', 'emerald', 'cosmic'];
            const idx1 = STATE_ORDER.indexOf(d.face1State);
            const idx2 = STATE_ORDER.indexOf(d.face2State);
            const medianeColor = idx1 >= idx2 ? face1Color : face2Color;
            
            return `<svg viewBox="0 0 90 90">
                <defs>
                    <linearGradient id="cosmicGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ff006e"/>
                        <stop offset="25%" style="stop-color:#8338ec"/>
                        <stop offset="50%" style="stop-color:#06b6d4"/>
                        <stop offset="75%" style="stop-color:#34d399"/>
                        <stop offset="100%" style="stop-color:#ffd700"/>
                    </linearGradient>
                </defs>
                
                <!-- Bordure complète face1 (haut) : coin haut-gauche + haut + coin haut-droit + côté droit haut -->
                <path d="M 1 45 L 1 12 A 11 11 0 0 1 12 1 L 78 1 A 11 11 0 0 1 89 12 L 89 45" 
                      fill="none" stroke="${face1Color}" stroke-width="2"/>
                
                <!-- Médiane (état le plus fort) -->
                <line x1="0" y1="45" x2="90" y2="45" stroke="${medianeColor}" stroke-width="2"/>
                
                <!-- Bordure complète face2 (bas) : côté droit bas + coin bas-droit + bas + coin bas-gauche + côté gauche bas -->
                <path d="M 89 45 L 89 78 A 11 11 0 0 1 78 89 L 12 89 A 11 11 0 0 1 1 78 L 1 45" 
                      fill="none" stroke="${face2Color}" stroke-width="2"/>
                
                <!-- Contenu des faces -->
                <g class="face1-${d.face1State}">${renderIcon(d.face1, false, d.face1State)}</g>
                <g class="face2-${d.face2State}" transform="translate(0,45)">${renderIcon(d.face2, true, d.face2State)}</g>
            </svg>`;
        }
        
        
        function render() {
            grid.innerHTML = '';
            
            for (let i = 0; i < TOTAL; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                
                const square = document.createElement('div');
                square.dataset.index = i;
                
                if (dominos[i]) {
                    square.className = 'square';
                    square.innerHTML = renderDomino(dominos[i]);
                    square.style.transform = `rotate(${dominos[i].rotation}deg)`;
                } else {
                    square.className = 'square empty';
                }
                
                cell.appendChild(square);
                grid.appendChild(cell);
            }
        }
        
        // Utilitaires
        function getPos(i) { return { x: i % COLS, y: Math.floor(i / COLS) }; }
        function getIndex(x, y) { return (x < 0 || x >= COLS || y < 0 || y >= ROWS) ? -1 : y * COLS + x; }
        
        // Obtenir la face exposée dans une direction selon la rotation
        function getExposedFace(domino, dir) {
            if (!domino) return null;
            const r = ((domino.rotation % 360) + 360) % 360;
            // Avec rotation 90° : face1 → droite, face2 → gauche
            // Avec rotation 0° : face1 → haut, face2 → bas
            const map = {
                0:   { top: 'face1', bottom: 'face2', left: null, right: null },
                90:  { top: null, bottom: null, left: 'face2', right: 'face1' },
                180: { top: 'face2', bottom: 'face1', left: null, right: null },
                270: { top: null, bottom: null, left: 'face1', right: 'face2' }
            };
            const face = map[r]?.[dir];
            return face ? domino[face] : null;
        }
        
        // Obtenir quelle propriété (face1 ou face2) est exposée dans une direction
        function getExposedFaceKey(domino, dir) {
            if (!domino) return null;
            const r = ((domino.rotation % 360) + 360) % 360;
            const map = {
                0:   { top: 'face1', bottom: 'face2', left: null, right: null },
                90:  { top: null, bottom: null, left: 'face2', right: 'face1' },
                180: { top: 'face2', bottom: 'face1', left: null, right: null },
                270: { top: null, bottom: null, left: 'face1', right: 'face2' }
            };
            return map[r]?.[dir] || null;
        }
        
        // Direction opposée
        function oppositeDir(dir) {
            return { top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[dir];
        }
        
        // ============================================
        // DÉTECTION DES FUSIONS
        // ============================================
        
        function checkFusions() {
            if (isAnimating || isLocalRotating) return;
            
            // Parcourir tous les dominos pour trouver des faces identiques adjacentes
            for (let i = 0; i < TOTAL; i++) {
                if (!dominos[i]) continue;
                const { x, y } = getPos(i);
                
                // Vérifier à droite
                const iR = getIndex(x + 1, y);
                if (iR !== -1 && dominos[iR]) {
                    const faceLeft = getExposedFace(dominos[i], 'right');
                    const faceRight = getExposedFace(dominos[iR], 'left');
                    if (faceLeft && faceRight && faceLeft === faceRight) {
                        performCompressionFusion(i, iR, 'horizontal');
                        return;
                    }
                }
                
                // Vérifier en bas
                const iB = getIndex(x, y + 1);
                if (iB !== -1 && dominos[iB]) {
                    const faceTop = getExposedFace(dominos[i], 'bottom');
                    const faceBottom = getExposedFace(dominos[iB], 'top');
                    if (faceTop && faceBottom && faceTop === faceBottom) {
                        performCompressionFusion(i, iB, 'vertical');
                        return;
                    }
                }
            }
        }
        
        // ============================================
        // ANIMATION DE FUSION PAR COMPRESSION
        // ============================================
        
        function performCompressionFusion(receiverIdx, projectileIdx, direction) {
            if (isAnimating) return;
            isAnimating = true;
            
            const receiver = dominos[receiverIdx];
            const projectile = dominos[projectileIdx];
            
            const receiverEl = grid.children[receiverIdx].querySelector('.square');
            const projectileEl = grid.children[projectileIdx].querySelector('.square');
            
            if (!receiverEl || !projectileEl || !receiver || !projectile) {
                isAnimating = false;
                return;
            }
            
            const cellSize = grid.children[0].offsetWidth;
            const gap = parseFloat(getComputedStyle(grid).gap) || 8;
            
            // Distance jusqu'à la médiane du receveur
            const distanceToMedian = gap + (cellSize / 2);
            
            projectileEl.style.zIndex = '100';
            
            const phase1Duration = 350;
            const phase2Duration = 180;
            
            let startTime = null;
            
            // Déterminer l'axe de compression selon direction et rotation du projectile
            const rotation = ((projectile.rotation % 360) + 360) % 360;
            const isHorizontal = (direction === 'horizontal');
            
            // Pour compression visuelle dans le sens du mouvement :
            // - Horizontal + rotation 90° ou 270° → scaleY
            // - Horizontal + rotation 0° ou 180° → scaleX
            // - Vertical + rotation 0° ou 180° → scaleY
            // - Vertical + rotation 90° ou 270° → scaleX
            const rotatedHorizontally = (rotation === 90 || rotation === 270);
            const useScaleY = (isHorizontal && rotatedHorizontally) || (!isHorizontal && !rotatedHorizontally);
            
            // Direction du translate
            const translateProp = isHorizontal ? 'translateX' : 'translateY';
            const translateValue = isHorizontal ? -distanceToMedian : -distanceToMedian;
            
            function animatePhase1(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / phase1Duration, 1);
                
                const ease = progress * progress;
                const translate = translateValue * ease;
                const scale = 1 - (0.5 * ease);
                
                const scaleTransform = useScaleY ? `scaleY(${scale})` : `scaleX(${scale})`;
                projectileEl.style.transform = `${translateProp}(${translate}px) rotate(${projectile.rotation}deg) ${scaleTransform}`;
                
                if (progress < 1) {
                    requestAnimationFrame(animatePhase1);
                } else {
                    startTime = null;
                    requestAnimationFrame(animatePhase2);
                }
            }
            
            function animatePhase2(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / phase2Duration, 1);
                
                const scale = 0.5 * (1 - progress);
                const opacity = 1 - progress;
                
                const scaleTransform = useScaleY ? `scaleY(${Math.max(0.01, scale)})` : `scaleX(${Math.max(0.01, scale)})`;
                projectileEl.style.transform = `${translateProp}(${translateValue}px) rotate(${projectile.rotation}deg) ${scaleTransform}`;
                projectileEl.style.opacity = opacity;
                
                if (progress < 1) {
                    requestAnimationFrame(animatePhase2);
                } else {
                    applyFusionResult();
                }
            }
            
            function applyFusionResult() {
                // Créer le nouveau domino avec les états de faces
                const newDomino = {
                    face1: receiver.face1,
                    face2: receiver.face2,
                    face1State: receiver.face1State,
                    face2State: receiver.face2State,
                    rotation: receiver.rotation,
                    state: receiver.state
                };
                
                // Déterminer quelle face du fond évolue et quelle face est annulée
                let backFaceKey, frontFaceKey, receiverInternalFaceKey, projectileInternalFaceKey;
                
                if (isHorizontal) {
                    // Projectile arrive de droite → face GAUCHE du receiver (fond) évolue
                    backFaceKey = getExposedFaceKey(receiver, 'left');
                    frontFaceKey = getExposedFaceKey(receiver, 'right');
                    const projectileFrontKey = getExposedFaceKey(projectile, 'right');
                    receiverInternalFaceKey = getExposedFaceKey(receiver, 'right');
                    projectileInternalFaceKey = getExposedFaceKey(projectile, 'left');
                    
                    // Remplacer la face avant avec celle du projectile
                    if (frontFaceKey && projectileFrontKey) {
                        newDomino[frontFaceKey] = projectile[projectileFrontKey];
                        newDomino[frontFaceKey + 'State'] = projectile[projectileFrontKey + 'State'];
                    }
                    
                    // Faire évoluer la face du FOND
                    if (backFaceKey) {
                        const currentState = receiver[backFaceKey + 'State'];
                        const currentIdx = STATE_ORDER.indexOf(currentState);
                        const newState = STATE_ORDER[Math.min(currentIdx + 1, STATE_ORDER.length - 1)];
                        newDomino[backFaceKey + 'State'] = newState;
                    }
                    
                } else {
                    // Projectile arrive du bas → face HAUT du receiver (fond) évolue
                    backFaceKey = getExposedFaceKey(receiver, 'top');
                    frontFaceKey = getExposedFaceKey(receiver, 'bottom');
                    const projectileFrontKey = getExposedFaceKey(projectile, 'bottom');
                    receiverInternalFaceKey = getExposedFaceKey(receiver, 'bottom');
                    projectileInternalFaceKey = getExposedFaceKey(projectile, 'top');
                    
                    // Remplacer la face avant avec celle du projectile
                    if (frontFaceKey && projectileFrontKey) {
                        newDomino[frontFaceKey] = projectile[projectileFrontKey];
                        newDomino[frontFaceKey + 'State'] = projectile[projectileFrontKey + 'State'];
                    }
                    
                    // Faire évoluer la face du FOND
                    if (backFaceKey) {
                        const currentState = receiver[backFaceKey + 'State'];
                        const currentIdx = STATE_ORDER.indexOf(currentState);
                        const newState = STATE_ORDER[Math.min(currentIdx + 1, STATE_ORDER.length - 1)];
                        newDomino[backFaceKey + 'State'] = newState;
                    }
                }
                
                // Mettre à jour l'état général du domino (niveau max des deux faces)
                const idx1 = STATE_ORDER.indexOf(newDomino.face1State);
                const idx2 = STATE_ORDER.indexOf(newDomino.face2State);
                newDomino.state = STATE_ORDER[Math.max(idx1, idx2)];
                
                // RECYCLAGE : Créer le domino recraché avec UNE SEULE face annulée
                // Les 2 faces qui ont disparu sont identiques (condition de fusion)
                // On recrache seulement UNE de ces faces, l'autre devient 'empty'
                // avec rotation +90° par rapport au domino résultant
                // L'état de la face recrachée hérite de l'état des faces annulées
                const annuledFaceState = receiver[receiverInternalFaceKey + 'State'];
                const recrachedDomino = {
                    face1: receiver[receiverInternalFaceKey], // Une des faces annulées
                    face2: 'empty', // L'autre face devient vide
                    face1State: annuledFaceState, // Hérite de l'état de la face annulée
                    face2State: 'white', // La face vide reste white
                    rotation: (newDomino.rotation + 90) % 360,
                    state: annuledFaceState // État général = état de la seule face présente
                };
                
                dominos[receiverIdx] = newDomino;
                dominos[projectileIdx] = recrachedDomino;
                
                render();
                
                // Effet de halo
                const newEl = grid.children[receiverIdx].querySelector('.square');
                if (newEl) {
                    const haloDir = isHorizontal ? '6px 0' : '0 6px';
                    newEl.style.boxShadow = `${haloDir} 20px rgba(34, 211, 238, 0.5), 0 0 10px rgba(34, 211, 238, 0.2)`;
                    
                    setTimeout(() => {
                        newEl.style.transition = 'box-shadow 0.4s ease-out';
                        newEl.style.boxShadow = '';
                    }, 150);
                }
                
                setTimeout(() => {
                    isAnimating = false;
                    // Vérifier s'il y a d'autres fusions
                    checkFusions();
                }, 300);
            }
            
            requestAnimationFrame(animatePhase1);
        }
        
        // ============================================
        // SYSTÈME DE ROTATION 2x2
        // ============================================
        
        function executeRotation(indices, clockwise, cb) {
            if (isLocalRotating || isAnimating) return;
            isLocalRotating = true;
            
            const cells = indices.map(idx => ({
                el: grid.children[idx]?.querySelector('.square'),
                domino: dominos[idx],
                sx: idx % COLS,
                sy: Math.floor(idx / COLS)
            }));
            
            const map = clockwise ? [2, 0, 3, 1] : [1, 3, 0, 2];
            cells.forEach((c, i) => {
                c.tx = indices[map[i]] % COLS;
                c.ty = Math.floor(indices[map[i]] / COLS);
            });
            
            const dur = ROTATION_SPEED * 0.5;
            const start = performance.now();
            const cellSize = grid.children[0].offsetWidth;
            const gap = parseFloat(getComputedStyle(grid).gap) || 8;
            
            function animate(t) {
                const p = Math.min((t - start) / dur, 1);
                const e = 1 - Math.pow(1 - p, 3);
                
                cells.forEach(c => {
                    if (c.el && c.domino) {
                        const dx = (c.tx - c.sx) * (cellSize + gap) * e;
                        const dy = (c.ty - c.sy) * (cellSize + gap) * e;
                        c.el.style.transform = `translate(${dx}px, ${dy}px) rotate(${c.domino.rotation}deg)`;
                    }
                });
                
                if (p < 1) {
                    requestAnimationFrame(animate);
                } else {
                    finishRotation(indices, clockwise, cb);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function finishRotation(indices, clockwise, cb) {
            const saved = indices.map(i => dominos[i]);
            const map = clockwise ? [2, 0, 3, 1] : [1, 3, 0, 2];
            
            for (let i = 0; i < 4; i++) {
                dominos[indices[map[i]]] = saved[i];
            }
            
            render();
            isLocalRotating = false;
            
            // Vérifier les fusions après rotation
            setTimeout(checkFusions, 50);
            
            if (cb) cb();
        }
        
        // Rotation individuelle d'un domino
        function rotateIndividual(idx, clockwise) {
            const domino = dominos[idx];
            if (!domino || isLocalRotating || isAnimating) return;
            
            isLocalRotating = true;
            domino.rotation += clockwise ? 90 : -90;
            
            const el = grid.children[idx].querySelector('.square');
            if (el) {
                el.style.transition = 'transform 0.15s cubic-bezier(0.4, 0, 0.2, 1)';
                el.style.transform = `rotate(${domino.rotation}deg)`;
                setTimeout(() => {
                    isLocalRotating = false;
                    checkFusions();
                }, 150);
            } else {
                isLocalRotating = false;
            }
        }
        
        function attemptVerticalRotation(x, y, dy) {
            let blockCol = Math.min(x, COLS - 2);
            let blockRow, clockwise;
            
            if (dy < 0) {
                blockRow = Math.max(0, Math.min(y - 1, ROWS - 2));
                clockwise = false;
            } else {
                blockRow = Math.min(y, ROWS - 2);
                clockwise = true;
            }
            
            const indices = [
                getIndex(blockCol, blockRow),
                getIndex(blockCol + 1, blockRow),
                getIndex(blockCol, blockRow + 1),
                getIndex(blockCol + 1, blockRow + 1)
            ];
            
            // Vérifier qu'il y a au moins un domino
            if (indices.some(i => dominos[i])) {
                executeRotation(indices, clockwise);
            }
        }
        
        function attemptHorizontalRotation(x, y, dx) {
            // On ne réagit que sur la rangée du BAS d'un groupe 2x2
            // Donc y doit être > 0 (pas sur la première rangée)
            if (y === 0) return;
            
            let blockCol, blockRow, clockwise;
            
            if (dx > 0) {
                // Swipe vers la DROITE → rotation ANTIHORAIRE du groupe 2x2 à droite
                // Le carré swipé fait partie du bas-gauche du groupe
                blockCol = x;
                blockRow = y - 1;
                clockwise = false; // antihoraire
            } else {
                // Swipe vers la GAUCHE → rotation HORAIRE du groupe 2x2 à gauche
                // Le carré swipé fait partie du bas-droit du groupe
                blockCol = x - 1;
                blockRow = y - 1;
                clockwise = true; // horaire
            }
            
            // Vérifier que le groupe est dans la grille
            if (blockCol < 0 || blockCol > COLS - 2) return;
            if (blockRow < 0 || blockRow > ROWS - 2) return;
            
            const indices = [
                getIndex(blockCol, blockRow),
                getIndex(blockCol + 1, blockRow),
                getIndex(blockCol, blockRow + 1),
                getIndex(blockCol + 1, blockRow + 1)
            ];
            
            // Vérifier qu'il y a au moins un domino dans le groupe
            if (indices.some(i => dominos[i])) {
                executeRotation(indices, clockwise);
            }
        }
        
        // ============================================
        // GESTION TACTILE
        // ============================================
        
        function handleStart(e) {
            if (isLocalRotating || isAnimating) return;
            
            const touch = e.touches?.[0] || e;
            const target = e.target.closest('.square');
            if (!target || target.classList.contains('empty')) return;
            
            const idx = parseInt(target.dataset.index);
            const pos = getPos(idx);
            
            dragState = {
                idx,
                x: pos.x,
                y: pos.y,
                sx: touch.clientX,
                sy: touch.clientY,
                moved: false
            };
            
            e.preventDefault();
        }
        
        function handleMove(e) {
            if (!dragState || dragState.moved || isAnimating) return;
            
            const touch = e.touches?.[0] || e;
            const dx = touch.clientX - dragState.sx;
            const dy = touch.clientY - dragState.sy;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 30) return;
            
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            const isHorizontal = absDy < 10 && absDx > 40;
            const isVertical = !isHorizontal && absDx < 10 && absDy > 40;
            const isDiagonal = !isHorizontal && !isVertical && absDx > 15 && absDy > 15;
            
            if (isHorizontal) {
                dragState.moved = true;
                attemptHorizontalRotation(dragState.x, dragState.y, dx);
            } else if (isVertical) {
                dragState.moved = true;
                attemptVerticalRotation(dragState.x, dragState.y, dy);
            } else if (isDiagonal) {
                const direction = (dy < 0) ? (dx > 0 ? 'ur' : 'ul') : (dx > 0 ? 'dr' : 'dl');
                const clockwise = (direction === 'ur' || direction === 'dr');
                dragState.moved = true;
                rotateIndividual(dragState.idx, clockwise);
            }
            
            e.preventDefault();
        }
        
        function handleEnd(e) {
            dragState = null;
        }
        
        // Events
        grid.addEventListener('touchstart', handleStart, { passive: false });
        grid.addEventListener('touchmove', handleMove, { passive: false });
        grid.addEventListener('touchend', handleEnd, { passive: false });
        grid.addEventListener('mousedown', handleStart, { passive: false });
        grid.addEventListener('mousemove', handleMove, { passive: false });
        grid.addEventListener('mouseup', handleEnd, { passive: false });
        
        // Initialisation
        initDominos();
        render();
    </script>
</body>
</html>
